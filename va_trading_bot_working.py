# -*- coding: utf-8 -*-
"""VA_trading_bot_working.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14xnnsnvH9btZmsJ-QKiGsakuOb5jgJXy
"""

!pip install yfinance pandas ta python-telegram-bot --quiet

import yfinance as yf
import pandas as pd
import datetime
import os
import telegram
from ta.momentum import RSIIndicator
from ta.trend import macd_diff
from ta.volatility import AverageTrueRange # Corrected typo: changed AverageTrueRange to AverageTrueTrend

# --- CONFIGURATION ---
TICKERS = [
    'AIR.PA', 'OR.PA', 'BN.PA', 'MC.PA', 'SAN.PA', 'ENGI.PA', 'KER.PA', 'HO.PA',
    'SGO.PA', 'DG.PA', 'RI.PA', 'AI.PA', 'VIE.PA', 'CAP.PA', 'EN.PA', 'SU.PA'
]
INITIAL_CAPITAL = 1000
RISK_PER_TRADE = 0.02
TAKE_PROFIT_PCT = 0.05
STOP_LOSS_PCT = 0.02
CSV_LOG_FILE = "trading_log.csv"

RSI_PERIOD = 14
MA_PERIOD = 20
VOLATILITY_WINDOW = 10

# --- TELEGRAM CONFIG ---
TELEGRAM_TOKEN = 'TON_TOKEN'
TELEGRAM_CHAT_ID = 'TON_CHAT_ID'
bot = telegram.Bot(token=TELEGRAM_TOKEN)


# --- ANALYSE + STRAT√âGIE ---
def analyze_and_trade(ticker, capital):
    try:
        df = yf.download(ticker, period='1mo', interval='1h')
        if df.empty:
            print(f"‚ö†Ô∏è No data downloaded for {ticker}")
            return [], capital
    except Exception as e:
        print(f"‚ö†Ô∏è Error downloading data for {ticker}: {e}")
        return [], capital

        print(f"Downloaded data for {ticker}:")
        print(df.head())

    try:
        # Added .squeeze() to ensure 1D input
        df['RSI'] = RSIIndicator(close=df['Close'].squeeze(), window=RSI_PERIOD).rsi()
        df['MA'] = df['Close'].rolling(MA_PERIOD).mean()
        df['Volatility'] = df['Close'].rolling(VOLATILITY_WINDOW).std()
        df.dropna(inplace=True)
    except Exception as e:
        print(f"‚ö†Ô∏è Error calculating indicators for {ticker}: {e}")
        return [], capital


    trades = []
    position = None

    # --- Debugging Print Statements ---
    print(f"DataFrame after dropna for {ticker}:")
    print(f"Length: {len(df)}")
    print(f"Index: {df.index}")
    print(f"Columns: {df.columns}")
    print(f"Is Empty: {df.empty}")
    # --- End Debugging Statements ---

    try:
        # Check if DataFrame is empty after dropping NaNs
        if df.empty:
            print(f"‚ö†Ô∏è DataFrame empty after dropna for {ticker}")
            return [], capital

        # Changed iteration method from iloc to iterrows
        for time, row in df.iterrows():
            close = float(row['Close'])
            rsi = float(row['RSI'])
            ma = float(row['MA'])
            # 'time' is already the index from iterrows

            # Sortie de position
            if position:
                direction = position['direction']
                if direction == 'long':
                    if close <= position['stop_loss'] or close >= position['take_profit']:
                        pnl = (close - position['entry_price']) * position['qty']
                        capital += close * position['qty']
                        trades.append({'time': time, 'action': 'EXIT_LONG', 'pnl': pnl, **position})
                        position = None
                elif direction == 'short':
                    if close >= position['stop_loss'] or close <= position['take_profit']:
                        pnl = (position['entry_price'] - close) * position['qty']
                        capital += (2 * position['entry_price'] - close) * position['qty']
                        trades.append({'time': time, 'action': 'EXIT_SHORT', 'pnl': pnl, **position})
                        position = None

            # Entr√©e en position
            if not position:
                risk = capital * RISK_PER_TRADE
                if close <= 0 or STOP_LOSS_PCT * close <= 0 or risk <= 0:
                    continue
                qty = int(risk / (STOP_LOSS_PCT * close))
                if qty == 0:
                    continue

                # Long (achat)
                if rsi < 30 and close > ma and trend_up:
                    entry_price = close
                    stop_loss = close * (1 - STOP_LOSS_PCT)
                    take_profit = close * (1 + TAKE_PROFIT_PCT)
                    if capital >= qty * close:
                        capital -= qty * close
                        position = {
                            'ticker': ticker, 'qty': qty, 'entry_price': entry_price,
                            'stop_loss': stop_loss, 'take_profit': take_profit,
                            'open_time': time, 'direction': 'long'
                        }
                        print(f"üü¢ LONG {ticker} √† {entry_price:.2f} ‚Ç¨ | TP: {take_profit:.2f} | SL: {stop_loss:.2f}")

                # Short (vente √† d√©couvert)
                elif rsi > 70 and close < ma and not trend_up:
                    entry_price = close
                    stop_loss = close * (1 + STOP_LOSS_PCT)
                    take_profit = close * (1 - TAKE_PROFIT_PCT) # Corrected typo here
                    capital -= qty * close
                    position = {
                        'ticker': ticker, 'qty': qty, 'entry_price': entry_price,
                        'stop_loss': stop_loss, 'take_profit': take_profit,
                        'open_time': time, 'direction': 'short'
                    }
                    print(f"üî¥ SHORT {ticker} √† {entry_price:.2f} ‚Ç¨ | TP: {take_profit:.2f} | SL: {stop_loss:.2f}")

        # Cl√¥ture en fin de p√©riode - need to handle potential empty df after loop
        if position:
            if not df.empty:
                final_close = df['Close'].iloc[-1]
                pnl = (final_close - position['entry_price']) * position['qty']
                capital += final_close * position['qty']
                trades.append({'time': df.index[-1], 'action': 'EXIT_EOD', 'pnl': pnl, **position})
            else:
                 # If df became empty somehow after opening position, close at entry price
                capital += position['entry_price'] * position['qty']
                trades.append({'time': position['open_time'], 'action': 'EXIT_EOD_NO_DATA', 'pnl': 0, **position})


        return trades, capital

    except Exception as e:
        print(f"‚ö†Ô∏è Error during trading loop for {ticker}: {e}")
        # Return empty trades and current capital in case of error
        return [], capital


# --- BACKTEST ET LOG ---
def run_bot():
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    print(f"\n‚è∞ Analyse √† {now}...\n")
    capital = INITIAL_CAPITAL
    all_trades = []

    for ticker in TICKERS:
        # analyze_and_trade now handles its own errors and returns [], capital
        trades, capital = analyze_and_trade(ticker, capital)
        all_trades.extend(trades)


    df_log = pd.DataFrame(all_trades)
    if not df_log.empty:
        df_log['capital_after'] = df_log['pnl'].cumsum() + INITIAL_CAPITAL
        if os.path.exists(CSV_LOG_FILE):
            df_log.to_csv(CSV_LOG_FILE, mode='a', index=False, header=False)
        else:
            df_log.to_csv(CSV_LOG_FILE, index=False)
        print(df_log.tail(3))

    print(f"\nüìä Capital final : {capital:.2f} ‚Ç¨")
    print(f"üìà Nombre total de trades : {len(all_trades)}")

if __name__ == "__main__":
    run_bot()